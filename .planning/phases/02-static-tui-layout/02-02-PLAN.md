---
phase: 02-static-tui-layout
plan: "02"
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/tui/content.py
  - tests/tui/test_content.py
autonomous: true
requirements:
  - TUI-05

must_haves:
  truths:
    - "Plain prose text is written to RichLog as-is"
    - "A fenced code block (```python ... ```) is written as a rich.syntax.Syntax object with the correct language"
    - "An unknown language tag still renders (pygments falls back gracefully)"
    - "Text with no code blocks produces no Syntax objects"
    - "Consecutive prose + code + prose is written in the correct order"
  artifacts:
    - path: "src/tui/content.py"
      provides: "write_content_to_pane() function and FENCE_OPEN / FENCE_CLOSE regexes"
      exports: ["write_content_to_pane", "FENCE_OPEN", "FENCE_CLOSE"]
    - path: "tests/tui/test_content.py"
      provides: "TDD test suite for write_content_to_pane"
      min_lines: 60
  key_links:
    - from: "tests/tui/test_content.py"
      to: "src/tui/content.py"
      via: "from tui.content import write_content_to_pane"
      pattern: "from tui\\.content import"
    - from: "src/tui/content.py"
      to: "rich.syntax.Syntax"
      via: "import and write to RichLog"
      pattern: "from rich\\.syntax import Syntax"
---

<objective>
TDD: Build and test the `write_content_to_pane()` function that parses incoming text for fenced code blocks and dispatches to RichLog appropriately — `Syntax` objects for code, plain text for prose.

Purpose: This is the core content-rendering primitive that AgentPane will call. It has well-defined inputs and outputs, making it a perfect TDD candidate. Getting it right before widget integration avoids debugging rendering issues later.
Output: `src/tui/content.py` with `write_content_to_pane()`, proven by a test suite in `tests/tui/test_content.py`.
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/tui/__init__.py
</context>

<feature>
  <name>write_content_to_pane — fenced code block parser and RichLog writer</name>
  <files>src/tui/content.py, tests/tui/test_content.py</files>
  <behavior>
    write_content_to_pane(log: RichLog, text: str) -> None

    Parses `text` line by line:
    - When a line matches ```{language} (FENCE_OPEN regex: r"^```(\w+)$"), enter code-block mode
    - Collect subsequent lines until a line matching ``` (FENCE_CLOSE regex: r"^```$") is found
    - Write the collected code as rich.syntax.Syntax(code, language, theme="monokai", indent_guides=True, background_color="default")
    - All other non-empty lines are written to log as plain strings via log.write(line)
    - Empty lines (blank or whitespace-only) are skipped — do not write them

    Cases (input text -> expected RichLog.write() calls):
    - "Hello world" -> [write("Hello world")]
    - "```python\nprint('hi')\n```" -> [write(Syntax("print('hi')", "python", ...))]
    - "Prose\n```js\nconsole.log(1)\n```\nMore prose" -> [write("Prose"), write(Syntax(...,"js",...)), write("More prose")]
    - "```unknown\nsome code\n```" -> [write(Syntax("some code", "unknown", ...))] — no crash on unknown lang
    - "   \n\nblank lines\n" -> [write("blank lines")] — empty/whitespace lines skipped
    - Inline code with single backticks (e.g. `foo`): written as-is with Rich markup — wrap in [bold cyan]...[/bold cyan] for inline backtick content (Claude's Discretion: bold cyan on dark terminal)

    IMPORTANT: Inline code substitution (single backticks) is a secondary behavior. Test the core fenced-block cases first. The inline backtick transformation can be implemented as a simple regex substitution on each prose line before calling log.write().
  </behavior>
  <implementation>
    1. Create `src/tui/content.py`:
       - Import `re`, `RichLog` from textual.widgets, `Syntax` from rich.syntax
       - Define `FENCE_OPEN = re.compile(r"^```(\w+)$")`
       - Define `FENCE_CLOSE = re.compile(r"^```$")`
       - Define `INLINE_CODE = re.compile(r"`([^`]+)`")` for single-backtick substitution
       - Implement `write_content_to_pane(log: RichLog, text: str) -> None` using the line-by-line state machine described in behavior

    2. For testing with a real RichLog: use Textual's `App.run_test()` Pilot context to get a live widget, OR use a MagicMock for RichLog since the function only calls `log.write()`. MagicMock approach is faster and does not require async test context.

    CRITICAL: Do NOT create `tests/tui/__init__.py`. Its existence shadows `src/tui/` in pytest's sys.path resolution (documented Phase 1 pitfall [01-02]). The `pythonpath = ["src"]` in pyproject.toml already handles import resolution.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for write_content_to_pane</name>
  <files>tests/tui/test_content.py</files>
  <action>
Create `tests/tui/test_content.py`. Do NOT create `tests/tui/__init__.py` — its absence is required (Phase 1 pitfall [01-02]: it shadows `src/tui/` in sys.path).

Write tests that import `from tui.content import write_content_to_pane` (which does not yet exist) and assert the expected behavior. Use `unittest.mock.MagicMock` as the RichLog stand-in so tests run without async context.

Test cases to implement (all must fail initially because `tui/content.py` doesn't exist):

```python
from unittest.mock import MagicMock, call
import pytest
from rich.syntax import Syntax
from tui.content import write_content_to_pane

def make_log():
    """Return a MagicMock with the RichLog.write() interface."""
    return MagicMock()

def test_plain_prose_is_written_as_string():
    log = make_log()
    write_content_to_pane(log, "Hello world")
    log.write.assert_called_once_with("Hello world")

def test_empty_and_whitespace_lines_are_skipped():
    log = make_log()
    write_content_to_pane(log, "   \n\ntext\n  ")
    log.write.assert_called_once_with("text")

def test_fenced_python_block_writes_syntax_object():
    log = make_log()
    write_content_to_pane(log, "```python\nprint('hi')\n```")
    assert log.write.call_count == 1
    arg = log.write.call_args[0][0]
    assert isinstance(arg, Syntax)

def test_syntax_object_has_correct_language():
    log = make_log()
    write_content_to_pane(log, "```js\nconsole.log(1)\n```")
    arg = log.write.call_args[0][0]
    assert isinstance(arg, Syntax)
    # Syntax stores lexer name; check by inspecting _lexer or just trust isinstance

def test_unknown_language_tag_does_not_crash():
    log = make_log()
    write_content_to_pane(log, "```unknown_lang_xyz\nsome code\n```")
    assert log.write.call_count == 1
    arg = log.write.call_args[0][0]
    assert isinstance(arg, Syntax)

def test_prose_then_code_then_prose_written_in_order():
    log = make_log()
    text = "First line\n```python\nx = 1\n```\nLast line"
    write_content_to_pane(log, text)
    assert log.write.call_count == 3
    assert log.write.call_args_list[0] == call("First line")
    assert isinstance(log.write.call_args_list[1][0][0], Syntax)
    assert log.write.call_args_list[2] == call("Last line")

def test_text_with_no_code_blocks():
    log = make_log()
    write_content_to_pane(log, "Line one\nLine two\nLine three")
    assert log.write.call_count == 3

def test_empty_string_writes_nothing():
    log = make_log()
    write_content_to_pane(log, "")
    log.write.assert_not_called()
```

Run tests to confirm they ALL FAIL with ImportError (src/tui/content.py does not exist):
```
pytest /Users/jakeogden/agent-bureau/tests/tui/test_content.py -v
```
Expected: all 8 tests fail with `ModuleNotFoundError: No module named 'tui.content'`.

Commit:
```
git commit -m "test(02-02): add failing tests for write_content_to_pane"
```
  </action>
  <verify>
`pytest /Users/jakeogden/agent-bureau/tests/tui/test_content.py -v` exits with failures, all showing `ModuleNotFoundError` or `ImportError`. Zero tests pass.
  </verify>
  <done>8 tests exist in tests/tui/test_content.py and all fail with import error. `tests/tui/__init__.py` does NOT exist.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement write_content_to_pane to pass all tests</name>
  <files>src/tui/content.py</files>
  <action>
Create `src/tui/content.py` implementing `write_content_to_pane(log, text)`.

```python
"""Content rendering utilities for AgentPane.

Parses markdown-like text and writes to a Textual RichLog:
- Fenced code blocks (```language ... ```) → rich.syntax.Syntax objects
- Plain prose lines → written as strings
- Inline code (`backticks`) → written with [bold cyan] Rich markup
- Empty / whitespace-only lines → skipped
"""
import re
from rich.syntax import Syntax

FENCE_OPEN = re.compile(r"^```(\w+)$")
FENCE_CLOSE = re.compile(r"^```$")
INLINE_CODE = re.compile(r"`([^`]+)`")

SCROLLBACK_LIMIT = 5000  # max_lines for RichLog — prevents OOM on long sessions


def write_content_to_pane(log, text: str) -> None:
    """Write text to a RichLog widget, rendering fenced code blocks as Syntax objects.

    Args:
        log: A RichLog widget instance (or compatible .write() interface).
        text: Multi-line string of agent output, optionally containing fenced code blocks.
    """
    lines = text.splitlines()
    i = 0
    while i < len(lines):
        line = lines[i]
        m = FENCE_OPEN.match(line)
        if m:
            language = m.group(1)
            code_lines = []
            i += 1
            while i < len(lines) and not FENCE_CLOSE.match(lines[i]):
                code_lines.append(lines[i])
                i += 1
            # Advance past the closing fence (if present)
            if i < len(lines):
                i += 1
            code = "\n".join(code_lines)
            log.write(
                Syntax(
                    code,
                    language,
                    theme="monokai",
                    indent_guides=True,
                    background_color="default",
                )
            )
        else:
            if line.strip():
                # Replace inline backtick code with Rich markup
                formatted = INLINE_CODE.sub(r"[bold cyan]\1[/bold cyan]", line)
                log.write(formatted)
            i += 1
```

Run tests:
```
pytest /Users/jakeogden/agent-bureau/tests/tui/test_content.py -v
```
All 8 tests must pass.

Then run the full test suite to ensure nothing in Phase 1 regressed:
```
pytest /Users/jakeogden/agent-bureau/tests/ -q
```

Commit:
```
git commit -m "feat(02-02): implement write_content_to_pane with fenced code highlighting"
```
  </action>
  <verify>
`pytest /Users/jakeogden/agent-bureau/tests/tui/test_content.py -v` shows 8 passed, 0 failed.
`pytest /Users/jakeogden/agent-bureau/tests/ -q` passes with no regressions.
  </verify>
  <done>All 8 content tests pass. `src/tui/content.py` exists with write_content_to_pane, FENCE_OPEN, FENCE_CLOSE, INLINE_CODE, and SCROLLBACK_LIMIT exported. No tests/tui/__init__.py exists.</done>
</task>

</tasks>

<verification>
- `ls /Users/jakeogden/agent-bureau/tests/tui/` does NOT show `__init__.py`
- `pytest /Users/jakeogden/agent-bureau/tests/tui/test_content.py -v` — 8 passed
- `pytest /Users/jakeogden/agent-bureau/tests/ -q` — full suite passes
- `cat /Users/jakeogden/agent-bureau/src/tui/content.py | grep "SCROLLBACK_LIMIT"` — constant exists
- `cat /Users/jakeogden/agent-bureau/src/tui/content.py | grep "FENCE_OPEN"` — regex exists
</verification>

<success_criteria>
write_content_to_pane() proven correct by 8 passing tests. Handles: plain prose, empty lines, fenced code blocks with language detection, unknown language tags, mixed prose+code+prose sequences, and empty input.
</success_criteria>

<output>
After completion, create `.planning/phases/02-static-tui-layout/02-02-SUMMARY.md` following the summary template.
</output>
