---
phase: 02-static-tui-layout
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/tui/widgets/__init__.py
  - src/tui/widgets/agent_pane.py
  - src/tui/widgets/quit_screen.py
  - src/tui/styles.tcss
  - tests/tui/test_agent_pane.py
  - tests/tui/test_quit_screen.py
autonomous: true
requirements:
  - TUI-01
  - TUI-02
  - TUI-04

must_haves:
  truths:
    - "AgentPane renders a header showing the agent name"
    - "AgentPane shows dimmed placeholder text when no content has been written"
    - "AgentPane shows its RichLog and hides the placeholder after the first write_content() call"
    - "AgentPane scrollback is bounded — RichLog created with max_lines=5000"
    - "QuitScreen displays a confirmation dialog with Quit and Cancel buttons"
    - "QuitScreen dismisses with True when Quit is pressed, False when Cancel is pressed"
  artifacts:
    - path: "src/tui/widgets/__init__.py"
      provides: "widget package init — exports AgentPane and QuitScreen"
    - path: "src/tui/widgets/agent_pane.py"
      provides: "AgentPane(Widget) with can_focus=True, docked header, RichLog, placeholder"
      exports: ["AgentPane"]
    - path: "src/tui/widgets/quit_screen.py"
      provides: "QuitScreen(ModalScreen[bool]) with Quit/Cancel buttons"
      exports: ["QuitScreen"]
    - path: "src/tui/styles.tcss"
      provides: "Textual CSS for layout, pane sizing, header active/inactive states, divider"
    - path: "tests/tui/test_agent_pane.py"
      provides: "Pilot-based tests for AgentPane widget"
      min_lines: 40
    - path: "tests/tui/test_quit_screen.py"
      provides: "Pilot-based tests for QuitScreen widget"
      min_lines: 25
  key_links:
    - from: "src/tui/widgets/agent_pane.py"
      to: "src/tui/content.py"
      via: "from tui.content import write_content_to_pane, SCROLLBACK_LIMIT"
      pattern: "from tui\\.content import"
    - from: "src/tui/widgets/agent_pane.py"
      to: "textual.widgets.RichLog"
      via: "RichLog(max_lines=SCROLLBACK_LIMIT) in compose()"
      pattern: "RichLog.*max_lines"
    - from: "tests/tui/test_agent_pane.py"
      to: "src/tui/widgets/agent_pane.py"
      via: "from tui.widgets.agent_pane import AgentPane"
      pattern: "from tui\\.widgets\\.agent_pane import"
---

<objective>
Build AgentPane and QuitScreen widgets — the two custom Textual widgets that form the structural core of the TUI — and verify their behavior with Pilot-based tests.

Purpose: These widgets encapsulate the independently-scrollable agent column (TUI-01, TUI-02, TUI-04) and the confirmation exit dialog (needed by TUI-08 in plan 04). They must be correct in isolation before AgentBureauApp wires them together.
Output: `src/tui/widgets/` package with AgentPane, QuitScreen, and styles.tcss; tests proving widget behavior.
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-static-tui-layout/02-02-SUMMARY.md
@src/tui/__init__.py
@src/tui/content.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AgentPane widget and styles.tcss</name>
  <files>
    src/tui/widgets/__init__.py
    src/tui/widgets/agent_pane.py
    src/tui/styles.tcss
  </files>
  <action>
Create the `src/tui/widgets/` package with the AgentPane widget and Textual CSS.

**1. Create `src/tui/widgets/__init__.py`:**
```python
"""TUI widget package."""
from tui.widgets.agent_pane import AgentPane
from tui.widgets.quit_screen import QuitScreen

__all__ = ["AgentPane", "QuitScreen"]
```

**2. Create `src/tui/widgets/agent_pane.py`:**
```python
"""AgentPane widget — a labeled, independently scrollable pane for agent output."""
from textual.app import ComposeResult
from textual.binding import Binding
from textual.widget import Widget
from textual.widgets import Label, RichLog

from tui.content import write_content_to_pane, SCROLLBACK_LIMIT


class AgentPane(Widget):
    """A focusable widget that displays a labeled, scrollable agent output pane.

    Composes:
      - A docked header Label showing the agent name (brighter when focused, dimmed when not)
      - A placeholder Label shown when the pane has no content yet
      - A RichLog for streamed/written content (hidden until first write)

    Keyboard bindings (active when this pane has focus):
      - up / down: scroll the RichLog line by line
      - page_up / page_down: scroll the RichLog one screen at a time (bonus shortcut)
    """

    can_focus = True

    BINDINGS = [
        Binding("up", "scroll_up", "Scroll up", show=False),
        Binding("down", "scroll_down", "Scroll down", show=False),
        Binding("pageup", "scroll_page_up", "Page up", show=False),
        Binding("pagedown", "scroll_page_down", "Page down", show=False),
    ]

    def __init__(self, agent_name: str, **kwargs) -> None:
        self.agent_name = agent_name
        self._has_content = False
        super().__init__(**kwargs)

    def compose(self) -> ComposeResult:
        yield Label(self.agent_name, id="header")
        yield Label(f"Waiting for {self.agent_name}...", id="placeholder")
        yield RichLog(
            id="content",
            highlight=True,
            markup=True,
            max_lines=SCROLLBACK_LIMIT,
            auto_scroll=True,
        )

    def on_mount(self) -> None:
        # Hide the RichLog until the first write; show placeholder instead.
        self.query_one("#content", RichLog).display = False

    def write_content(self, text: str) -> None:
        """Write agent output text to the pane, showing the RichLog on first call."""
        log = self.query_one("#content", RichLog)
        if not self._has_content:
            self._has_content = True
            self.query_one("#placeholder", Label).display = False
            log.display = True
        write_content_to_pane(log, text)

    def action_scroll_up(self) -> None:
        self.query_one("#content", RichLog).scroll_up(animate=False)

    def action_scroll_down(self) -> None:
        self.query_one("#content", RichLog).scroll_down(animate=False)

    def action_scroll_page_up(self) -> None:
        self.query_one("#content", RichLog).scroll_page_up(animate=False)

    def action_scroll_page_down(self) -> None:
        self.query_one("#content", RichLog).scroll_page_down(animate=False)
```

**3. Create `src/tui/styles.tcss`:**
```css
/* Agent Bureau — Textual CSS
   Dark terminal theme. $variables resolve to Textual's built-in color tokens.
*/

Screen {
    background: $surface;
}

/* Root horizontal container fills entire screen */
Horizontal {
    height: 100%;
}

/* Vertical divider between panes */
#divider {
    width: 1;
    height: 100%;
    background: $panel;
    color: $text-muted;
    content-align: center middle;
}

/* Each agent pane takes equal share of horizontal space */
AgentPane {
    width: 1fr;
    height: 100%;
    layout: vertical;
}

/* Pane header — one line tall, dimmed when not focused */
AgentPane #header {
    height: 1;
    background: $panel-darken-1;
    color: $text-muted;
    content-align: center middle;
    padding: 0 1;
    text-style: bold;
}

/* Active pane header — highlighted when pane has focus */
AgentPane:focus #header {
    background: $accent-darken-1;
    color: $text;
}

/* RichLog content area fills remaining height */
AgentPane #content {
    height: 1fr;
    padding: 0 1;
}

/* Placeholder text — centered, dimmed, fills available space */
AgentPane #placeholder {
    color: $text-disabled;
    content-align: center middle;
    height: 1fr;
}

/* Quit confirmation dialog */
QuitScreen {
    align: center middle;
}

#dialog {
    grid-size: 2;
    grid-gutter: 1 2;
    grid-rows: 1fr 3;
    padding: 0 1;
    width: 60;
    height: 11;
    border: thick $background 80%;
    background: $surface;
}

#question {
    column-span: 2;
    height: 1fr;
    width: 1fr;
    content-align: center bottom;
}
```

ANTI-PATTERNS to avoid (from research):
- Do NOT set `can_focus = False` on AgentPane — pane switching silently breaks without it
- Do NOT bind `up`/`down` in AgentBureauApp — bind them here in AgentPane only
- Do NOT wrap AgentPane in VerticalScroll — let RichLog handle its own scrolling
- Do NOT nest a VerticalScroll child inside AgentPane for the same reason
  </action>
  <verify>
```
python -c "from tui.widgets.agent_pane import AgentPane; print('AgentPane OK')"
python -c "from tui.widgets import AgentPane, QuitScreen; print('package imports OK')"
```
Both commands run from /Users/jakeogden/agent-bureau without error (textual must be installed from plan 01).
  </verify>
  <done>
`src/tui/widgets/__init__.py`, `src/tui/widgets/agent_pane.py`, and `src/tui/styles.tcss` exist. AgentPane and QuitScreen importable from `tui.widgets`. AgentPane has `can_focus = True`, BINDINGS for up/down/pageup/pagedown, `write_content()` method, and `RichLog(max_lines=SCROLLBACK_LIMIT)`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement QuitScreen widget and write Pilot tests for both widgets</name>
  <files>
    src/tui/widgets/quit_screen.py
    tests/tui/test_agent_pane.py
    tests/tui/test_quit_screen.py
  </files>
  <action>
**1. Create `src/tui/widgets/quit_screen.py`:**
```python
"""QuitScreen — modal confirmation dialog for clean exit on Ctrl-C."""
from textual.app import ComposeResult
from textual.containers import Grid
from textual.screen import ModalScreen
from textual.widgets import Button, Label


class QuitScreen(ModalScreen[bool]):
    """Modal confirmation dialog. Dismisses with True if user confirms quit, False otherwise."""

    DEFAULT_CSS = """
    QuitScreen {
        align: center middle;
    }

    #dialog {
        grid-size: 2;
        grid-gutter: 1 2;
        grid-rows: 1fr 3;
        padding: 0 1;
        width: 60;
        height: 11;
        border: thick $background 80%;
        background: $surface;
    }

    #question {
        column-span: 2;
        height: 1fr;
        width: 1fr;
        content-align: center bottom;
    }
    """

    def compose(self) -> ComposeResult:
        yield Grid(
            Label("Are you sure you want to quit?", id="question"),
            Button("Quit", variant="error", id="quit"),
            Button("Cancel", variant="primary", id="cancel"),
            id="dialog",
        )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        self.dismiss(event.button.id == "quit")
```

**2. Create `tests/tui/test_agent_pane.py`** — Pilot-based tests for AgentPane:

```python
"""Tests for AgentPane widget using Textual's headless Pilot harness."""
import pytest
from textual.app import App, ComposeResult
from textual.widgets import RichLog

from tui.widgets.agent_pane import AgentPane


class PaneTestApp(App):
    """Minimal host app for testing AgentPane in isolation."""

    def compose(self) -> ComposeResult:
        yield AgentPane(agent_name="claude", id="pane")

    def on_mount(self) -> None:
        self.query_one("#pane").focus()


@pytest.mark.asyncio
async def test_agent_name_appears_in_header():
    app = PaneTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        header = app.query_one("#pane #header")
        assert "claude" in header.renderable


@pytest.mark.asyncio
async def test_placeholder_visible_before_any_write():
    app = PaneTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        placeholder = app.query_one("#pane #placeholder")
        assert placeholder.display is True
        log = app.query_one("#pane #content", RichLog)
        assert log.display is False


@pytest.mark.asyncio
async def test_write_content_hides_placeholder_shows_log():
    app = PaneTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        pane = app.query_one("#pane", AgentPane)
        pane.write_content("Hello from claude")
        await pilot.pause()
        placeholder = app.query_one("#pane #placeholder")
        log = app.query_one("#pane #content", RichLog)
        assert placeholder.display is False
        assert log.display is True


@pytest.mark.asyncio
async def test_richlog_has_bounded_scrollback():
    app = PaneTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        log = app.query_one("#pane #content", RichLog)
        assert log.max_lines == 5000


@pytest.mark.asyncio
async def test_pane_is_focusable():
    app = PaneTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        pane = app.query_one("#pane", AgentPane)
        assert pane.can_focus is True
```

**3. Create `tests/tui/test_quit_screen.py`** — Pilot-based tests for QuitScreen:

```python
"""Tests for QuitScreen modal widget."""
import pytest
from textual.app import App, ComposeResult
from textual.widgets import Button

from tui.widgets.quit_screen import QuitScreen


class QuitTestApp(App):
    """Host app that immediately pushes the QuitScreen for testing."""

    def __init__(self):
        super().__init__()
        self.quit_result: bool | None = None

    def on_mount(self) -> None:
        self.push_screen(QuitScreen(), self._on_result)

    def _on_result(self, result: bool | None) -> None:
        self.quit_result = result


@pytest.mark.asyncio
async def test_quit_button_dismisses_with_true():
    app = QuitTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        await pilot.pause()
        await pilot.click("#quit")
        await pilot.pause()
        assert app.quit_result is True


@pytest.mark.asyncio
async def test_cancel_button_dismisses_with_false():
    app = QuitTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        await pilot.pause()
        await pilot.click("#cancel")
        await pilot.pause()
        assert app.quit_result is False


@pytest.mark.asyncio
async def test_dialog_contains_quit_and_cancel_buttons():
    app = QuitTestApp()
    async with app.run_test(size=(120, 40)) as pilot:
        await pilot.pause()
        quit_btn = app.query_one("#quit", Button)
        cancel_btn = app.query_one("#cancel", Button)
        assert quit_btn is not None
        assert cancel_btn is not None
```

CRITICAL: Do NOT create `tests/tui/__init__.py`. The file must not exist (Phase 1 pitfall [01-02]).

After creating all files, run the new tests:
```
pytest /Users/jakeogden/agent-bureau/tests/tui/test_agent_pane.py -v
pytest /Users/jakeogden/agent-bureau/tests/tui/test_quit_screen.py -v
```

If any tests fail, fix the widget implementation before proceeding. Then run the full suite:
```
pytest /Users/jakeogden/agent-bureau/tests/ -q
```
  </action>
  <verify>
```
pytest /Users/jakeogden/agent-bureau/tests/tui/test_agent_pane.py -v
pytest /Users/jakeogden/agent-bureau/tests/tui/test_quit_screen.py -v
pytest /Users/jakeogden/agent-bureau/tests/ -q
```
All three commands pass. No `tests/tui/__init__.py` exists.
  </verify>
  <done>
`src/tui/widgets/quit_screen.py` exists with QuitScreen(ModalScreen[bool]). `tests/tui/test_agent_pane.py` and `tests/tui/test_quit_screen.py` exist and all tests pass. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
- `ls /Users/jakeogden/agent-bureau/tests/tui/` — NO `__init__.py`
- `python -c "from tui.widgets import AgentPane, QuitScreen; print('OK')"` — succeeds
- `pytest /Users/jakeogden/agent-bureau/tests/tui/test_agent_pane.py -v` — all pass
- `pytest /Users/jakeogden/agent-bureau/tests/tui/test_quit_screen.py -v` — all pass
- `grep "max_lines=SCROLLBACK_LIMIT" /Users/jakeogden/agent-bureau/src/tui/widgets/agent_pane.py` — present
- `grep "can_focus = True" /Users/jakeogden/agent-bureau/src/tui/widgets/agent_pane.py` — present
- `pytest /Users/jakeogden/agent-bureau/tests/ -q` — full suite passes
</verification>

<success_criteria>
AgentPane and QuitScreen widgets exist, import cleanly, and are proven by Pilot-based tests. AgentPane shows placeholder until first write, reveals RichLog on write, has bounded scrollback (5000 lines), and is focusable. QuitScreen dismisses with the correct boolean for each button.
</success_criteria>

<output>
After completion, create `.planning/phases/02-static-tui-layout/02-03-SUMMARY.md` following the summary template.
</output>
