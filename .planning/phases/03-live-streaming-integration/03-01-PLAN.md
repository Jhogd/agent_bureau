---
phase: 03-live-streaming-integration
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/tui/messages.py
  - src/tui/session.py
  - tests/tui/test_messages.py
  - tests/tui/test_session.py
autonomous: true
requirements: [TUI-03, ORCH-06]

must_haves:
  truths:
    - "TokenReceived, AgentFinished, and ClassificationDone are importable Textual Message subclasses"
    - "SessionState has exactly four states: IDLE, STREAMING, CLASSIFYING, DONE"
    - "SessionState.IDLE is the initial/default state"
    - "All three message types carry the correct typed fields"
  artifacts:
    - path: "src/tui/messages.py"
      provides: "Textual Message subclasses for bridge event routing"
      exports: ["TokenReceived", "AgentFinished", "ClassificationDone"]
    - path: "src/tui/session.py"
      provides: "SessionState enum for state machine gating"
      exports: ["SessionState"]
    - path: "tests/tui/test_messages.py"
      provides: "Unit tests for message field types and instantiation"
    - path: "tests/tui/test_session.py"
      provides: "Unit tests for SessionState enum values and transitions"
  key_links:
    - from: "src/tui/messages.py"
      to: "tui.event_bus.BridgeEvent"
      via: "AgentFinished.event field type annotation"
      pattern: "BridgeEvent"
    - from: "src/tui/session.py"
      to: "enum.Enum"
      via: "class SessionState(Enum)"
      pattern: "class SessionState"
---

<objective>
TDD implementation of the Textual message types and session state machine that form the communication backbone of Phase 3.

Purpose: These two modules are pure Python with clear I/O contracts — ideal TDD candidates. `messages.py` defines the typed messages that route bridge events through Textual's message pump. `session.py` defines the state machine enum that gates all session transitions (requirement ORCH-06). Both must exist and be proven correct before the app can be wired.

Output: `src/tui/messages.py`, `src/tui/session.py`, and their test suites with all tests green.
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-live-streaming-integration/03-RESEARCH.md
@src/tui/event_bus.py
</context>

<tasks>

<task type="tdd">
  <name>Task 1: RED — Failing tests for messages.py and session.py</name>
  <files>
    tests/tui/test_messages.py
    tests/tui/test_session.py
  </files>
  <action>
Write failing tests first. Do NOT create the source files yet.

**tests/tui/test_messages.py** — test all three message types:

```python
from tui.messages import TokenReceived, AgentFinished, ClassificationDone
from tui.event_bus import AgentDone, AgentError, AgentTimeout
from textual.message import Message
```

Test cases (use pytest, no class needed — plain functions):
1. `test_token_received_is_message`: `isinstance(TokenReceived(agent="claude", text="hello"), Message)` is True
2. `test_token_received_fields`: TokenReceived(agent="claude", text="foo") has `.agent == "claude"` and `.text == "foo"`
3. `test_agent_finished_is_message`: isinstance check
4. `test_agent_finished_fields`: AgentFinished(agent="codex", event=AgentDone(agent="codex", full_text="x", exit_code=0)) has `.agent == "codex"` and `.event.type == "done"`
5. `test_classification_done_is_message`: isinstance check
6. `test_classification_done_fields`: ClassificationDone(disagreements=[], full_texts={"claude": "x", "codex": "y"}) has `.disagreements == []` and `.full_texts` is the dict

**tests/tui/test_session.py** — test SessionState enum:

```python
from tui.session import SessionState
from enum import Enum
```

Test cases:
1. `test_session_state_is_enum`: `issubclass(SessionState, Enum)` is True
2. `test_session_state_has_four_values`: `len(list(SessionState)) == 4`
3. `test_session_state_values_named`: All of IDLE, STREAMING, CLASSIFYING, DONE are accessible as `SessionState.IDLE`, etc.
4. `test_idle_is_falsy_in_streaming_check`: `SessionState.IDLE not in (SessionState.STREAMING, SessionState.CLASSIFYING)` is True (models the Input.disabled condition)

Run: `.venv/bin/pytest tests/tui/test_messages.py tests/tui/test_session.py -v`
Both test files must fail with ImportError (source files do not exist yet).
Commit: `test(03-01): add failing tests for messages and session state`

CRITICAL: Do NOT create tests/tui/__init__.py — its presence causes src/tui/ shadowing (documented Phase 01-02 pitfall).
  </action>
  <verify>
`.venv/bin/pytest tests/tui/test_messages.py tests/tui/test_session.py -v` exits with non-zero and shows ImportError for both modules.
  </verify>
  <done>Both test files exist, all tests fail with ImportError (not with assertion errors — the import is failing, not the logic).</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN — Implement messages.py and session.py to pass all tests</name>
  <files>
    src/tui/messages.py
    src/tui/session.py
  </files>
  <action>
Implement both modules to make all 10 tests pass. Write minimum code needed.

**src/tui/messages.py**:

```python
"""Textual Message subclasses for routing bridge events through the Textual message pump.

These messages are posted from the async bridge worker and handled by AgentBureauApp.
Handler naming convention (Textual auto-routes):
  TokenReceived    -> on_token_received
  AgentFinished    -> on_agent_finished
  ClassificationDone -> on_classification_done
"""
from __future__ import annotations

from dataclasses import dataclass

from textual.message import Message

from tui.event_bus import BridgeEvent


@dataclass
class TokenReceived(Message):
    """A single streamed token line from an agent subprocess."""
    agent: str
    text: str


@dataclass
class AgentFinished(Message):
    """An agent's terminal event (AgentDone, AgentError, or AgentTimeout)."""
    agent: str
    event: BridgeEvent


@dataclass
class ClassificationDone(Message):
    """Disagreement classification results, ready to display."""
    disagreements: list   # list[disagree_v1.models.Disagreement]
    full_texts: dict      # {agent_name: str}
```

**src/tui/session.py**:

```python
"""Session state machine for Agent Bureau.

SessionState drives all state-dependent UI: Input disabled state,
status bar text, and pane header highlights. Transitions:

  IDLE -> STREAMING   (on prompt submission)
  STREAMING -> CLASSIFYING  (on both AgentFinished received)
  CLASSIFYING -> DONE  (on ClassificationDone received)
  DONE -> IDLE  (on next prompt submission, or auto after classification)
"""
from __future__ import annotations

from enum import Enum, auto


class SessionState(Enum):
    """State machine states for a live agent session."""
    IDLE = auto()
    STREAMING = auto()
    CLASSIFYING = auto()
    DONE = auto()
```

Run: `.venv/bin/pytest tests/tui/test_messages.py tests/tui/test_session.py -v`
All 10 tests must pass.
Run full suite: `.venv/bin/pytest` — all existing tests must still pass.
Commit: `feat(03-01): implement messages and session state`
  </action>
  <verify>
`.venv/bin/pytest tests/tui/test_messages.py tests/tui/test_session.py -v` exits 0 with all 10 tests passing. `.venv/bin/pytest` exits 0 with no regressions.
  </verify>
  <done>Both source files exist, all 10 new tests pass, full suite remains green.</done>
</task>

</tasks>

<verification>
- `src/tui/messages.py` exists and exports TokenReceived, AgentFinished, ClassificationDone
- `src/tui/session.py` exists and exports SessionState with IDLE/STREAMING/CLASSIFYING/DONE
- All 10 new tests pass
- Full test suite passes (no regressions from Phase 2's 52 tests)
- `tests/tui/__init__.py` does NOT exist
</verification>

<success_criteria>
`from tui.messages import TokenReceived, AgentFinished, ClassificationDone` and `from tui.session import SessionState` both import cleanly. All 10 tests green. Full suite green.
</success_criteria>

<output>
After completion, create `.planning/phases/03-live-streaming-integration/03-01-SUMMARY.md` following the summary template.
</output>
