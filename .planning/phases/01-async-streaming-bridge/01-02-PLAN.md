---
phase: 01-async-streaming-bridge
plan: 02
type: tdd
wave: 2
depends_on: [01-01]
files_modified:
  - src/tui/event_bus.py
  - src/tui/bridge.py
  - tests/tui/test_bridge.py
autonomous: true
requirements: [AGENT-03, AGENT-04]

must_haves:
  truths:
    - "A test harness can invoke the bridge with FakeAgentRunner and receive TokenChunk, AgentDone, and AgentError events in the correct sequence"
    - "When one agent times out (FakeAgentRunner with long delay), the bridge emits AgentTimeout and the other agent's stream completes normally with AgentDone"
    - "When one agent fails (FakeAgentRunner with exit_code != 0), the bridge emits AgentError and the other agent's stream completes normally with AgentDone"
    - "The bridge always emits exactly 2 terminal events (done/error/timeout), one per agent"
    - "AgentDone.full_text contains the complete accumulated text from all TokenChunk events for that agent"
  artifacts:
    - path: "src/tui/event_bus.py"
      provides: "Frozen dataclass event types: AgentSpec, TokenChunk, AgentDone, AgentError, AgentTimeout, BridgeEvent"
      exports: ["AgentSpec", "TokenChunk", "AgentDone", "AgentError", "AgentTimeout", "BridgeEvent"]
    - path: "src/tui/bridge.py"
      provides: "StreamingBridge with PTY-first subprocess streaming, PIPE fallback, and run_bridge() fan-out"
      exports: ["StreamingBridge", "run_bridge", "CLAUDE", "CODEX"]
    - path: "tests/tui/test_bridge.py"
      provides: "FakeAgentRunner test harness and all Phase 1 bridge tests"
      min_lines: 80
  key_links:
    - from: "tests/tui/test_bridge.py"
      to: "src/tui/event_bus.py"
      via: "from tui.event_bus import AgentSpec, TokenChunk, AgentDone, AgentError, AgentTimeout"
      pattern: "from tui.event_bus import"
    - from: "tests/tui/test_bridge.py"
      to: "run_bridge_with_fakes"
      via: "FakeAgentRunner injected into bridge consumer loop"
      pattern: "run_bridge_with_fakes"
    - from: "src/tui/bridge.py"
      to: "src/tui/event_bus.py"
      via: "import and post events to asyncio.Queue"
      pattern: "from tui.event_bus import"
---

<objective>
Build the async streaming bridge using TDD: typed event bus first, then the bridge implementation proven correct via FakeAgentRunner tests before any real subprocess is invoked.

Purpose: AGENT-03 (timeout recovery) and AGENT-04 (malformed output recovery) must be provably correct. TDD with FakeAgentRunner provides that proof without requiring real CLI tools.
Output: event_bus.py (frozen dataclass event types), bridge.py (PTY-first subprocess streaming + fan-out), test_bridge.py (FakeAgentRunner + 5+ behavioral tests, all passing).
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-async-streaming-bridge/01-CONTEXT.md
@.planning/phases/01-async-streaming-bridge/01-RESEARCH.md
@.planning/phases/01-async-streaming-bridge/01-01-SUMMARY.md
</context>

<feature>
  <name>Async Streaming Bridge — Event Bus and FakeAgentRunner Tests</name>
  <files>src/tui/event_bus.py, src/tui/bridge.py, tests/tui/test_bridge.py</files>
  <behavior>
    Event bus types:
    - AgentSpec(name, command, args=()) — build_argv(prompt) returns [command, *args, prompt]
    - TokenChunk(agent, text, type="token") — frozen, represents one streamed line
    - AgentDone(agent, full_text, exit_code, type="done") — terminal event, success
    - AgentError(agent, message, exit_code, type="error") — terminal event, non-zero exit
    - AgentTimeout(agent, type="timeout") — terminal event, exceeded timeout
    - BridgeEvent = Union[TokenChunk, AgentDone, AgentError, AgentTimeout]

    FakeAgentRunner behavior cases → expected output:
    - Two runners both succeed → TokenChunk events from both, two AgentDone terminal events
    - Runner with exit_code=1 → AgentError terminal event for that runner; other runner gets AgentDone
    - Runner with delay > timeout → AgentTimeout terminal event for that runner; other runner gets AgentDone
    - Any run → exactly 2 terminal events total (one per agent)
    - AgentDone.full_text → contains all lines yielded by that runner

    run_bridge_with_fakes(prompt, runner_a, runner_b, timeout) → list[BridgeEvent]
    - Both runners start concurrently as asyncio.Task instances
    - Consumer loop reads from shared asyncio.Queue until done_count == 2
    - Terminal event types: "done", "error", "timeout"

    Bridge (real subprocess, for later integration — not tested in Phase 1 with real binaries):
    - _pty_available() → bool: try pty.openpty(), close fds, return True; OSError → return False
    - _stream_pty(spec, prompt, timeout, q) — PTY mode: O_NONBLOCK on master, loop.add_reader, CRLF normalization, cleanup on timeout
    - _stream_pipe(spec, prompt, timeout, q) — PIPE fallback: async readline loop
    - run_bridge(prompt, spec_a, spec_b, timeout, use_pty) — real subprocess fan-out
    - CLAUDE = AgentSpec(name="claude", command="claude")
    - CODEX = AgentSpec(name="codex", command="codex")
  </behavior>
  <implementation>
    Step 1 — RED: Write tests/tui/test_bridge.py with FakeAgentRunner and 5 test functions. Run pytest — all fail (event_bus not yet importable). Commit.

    Step 2 — GREEN (event bus): Write src/tui/event_bus.py with all frozen dataclasses. Run pytest — import errors resolve but bridge tests still fail (run_bridge_with_fakes missing). Commit.

    Step 3 — GREEN (bridge consumer): Add run_bridge_with_fakes to test file AND write src/tui/bridge.py with the real subprocess implementation. Run pytest — all tests pass. Commit.

    Step 4 — REFACTOR if needed: Clean up, ensure no duplication, verify all pitfalls from RESEARCH.md are addressed. Commit.

    Key implementation notes from RESEARCH.md (all MUST be honored):
    - PTY master fd: always set O_NONBLOCK with fcntl before loop.add_reader()
    - slave fd: os.close(slave_fd) immediately after create_subprocess_exec returns
    - CRLF normalization: data.replace(b"\r\n", b"\n") on every PTY chunk before decode
    - ANSI pass-through: do NOT strip ANSI escape sequences from PTY or PIPE output — pass them through raw; the TUI renders agent colors directly (locked decision from CONTEXT.md)
    - Timeout cleanup: proc.terminate() + await proc.wait() with proc.kill() fallback in finally block
    - FakeAgentRunner: raises RuntimeError when exit_code != 0, yields lines with optional delay
    - Chunk granularity: post complete lines (str.splitlines()) not raw byte chunks
    - N-agent generalization: do NOT add — exactly 2 agents, hardcoded fan-out
    - Per-agent timeout config: do NOT add — single global timeout parameter
    - asyncio_mode = "auto" is already configured (from Plan 01) — no @pytest.mark.asyncio decorators needed
  </implementation>
</feature>

<verification>
After all RED→GREEN→REFACTOR cycles:
1. `python3 -m pytest tests/tui/test_bridge.py -v` — all tests pass, output shows async test execution (not 0.001s trivially passing)
2. `python3 -m pytest tests/ -q` — all tests pass including existing tests/test_v1_flow.py
3. `python3 -c "from tui.event_bus import TokenChunk, AgentDone, AgentError, AgentTimeout, AgentSpec, BridgeEvent; print('OK')"` — prints OK
4. `python3 -c "from tui.bridge import run_bridge, CLAUDE, CODEX; print('OK')"` — prints OK
5. `grep -n "assert" tests/tui/test_bridge.py | wc -l` — at least 8 assertion lines (confirms tests are real, not trivially passing)
</verification>

<success_criteria>
- src/tui/event_bus.py: all 5 event types as frozen dataclasses, BridgeEvent union type, AgentSpec.build_argv()
- src/tui/bridge.py: _pty_available(), _stream_pty(), _stream_pipe(), run_bridge(), CLAUDE, CODEX defaults
- tests/tui/test_bridge.py: FakeAgentRunner class, run_bridge_with_fakes(), at least 5 async test functions
- All tests pass: pytest exits 0
- AGENT-03 proven: test_timeout_does_not_kill_surviving_agent passes
- AGENT-04 proven: test_error_does_not_kill_surviving_agent passes
- TDD commit sequence present: test commit → feat commit (→ optional refactor commit)
</success_criteria>

<output>
After completion, create `.planning/phases/01-async-streaming-bridge/01-02-SUMMARY.md` with:
- Event types implemented and their fields
- Test functions written and what each covers
- Any deviations from RESEARCH.md patterns and why
- Pitfalls encountered (if any) from the RESEARCH.md list
- Commit SHAs for test, feat, and refactor commits
</output>
