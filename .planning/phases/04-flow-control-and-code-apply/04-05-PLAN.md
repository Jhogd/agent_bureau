---
phase: 04-flow-control-and-code-apply
plan: "05"
type: execute
wave: 2
depends_on:
  - 04-01
  - 04-02
  - 04-03
  - 04-04
files_modified:
  - src/tui/app.py
  - tests/tui/test_app.py
autonomous: true
requirements:
  - ORCH-01
  - ORCH-04
  - ORCH-05
  - APPLY-01
  - APPLY-02
  - APPLY-03

must_haves:
  truths:
    - "After prompt submission, FlowPickerScreen appears before agents run — user must choose pick-one or live-debate"
    - "In live-debate mode, each round posts RoundBoundary, streams both agents, and checks _debate_stop before next round"
    - "Pressing Esc during debate pushes ConfirmEndDebateScreen — if confirmed, _debate_stop is set and debate loop exits after current round"
    - "After streaming or debate completes, WinnerPickerScreen appears with four options"
    - "Selecting a winner triggers reconciliation: both agents get each other's proposals and produce a discussion + agreed code"
    - "ReconciliationPanel becomes visible with discussion text and unified diff"
    - "ApplyConfirmScreen gates all file writes — user must press y before any file is written to disk"
    - "Selecting Cancel in WinnerPickerScreen clears context; no files are written"
    - "All state transitions are reflected in StatusBar using Phase 4 show_* methods"
    - "Session resets cleanly: ReconciliationPanel hidden, _debate_stop cleared, state returns to IDLE"
  artifacts:
    - path: "src/tui/app.py"
      provides: "AgentBureauApp fully extended with Phase 4 flow control and apply"
      exports:
        - "_run_session (extended to await flow picker first)"
        - "_run_live_debate"
        - "_run_pick_one"
        - "_run_reconciliation"
        - "on_round_boundary"
        - "on_debate_ended"
        - "on_reconciliation_ready"
        - "action_end_debate"
    - path: "tests/tui/test_app.py"
      provides: "Integration tests for Phase 4 flows"
  key_links:
    - from: "src/tui/app.py"
      to: "src/tui/widgets/flow_picker_screen.py"
      via: "push_screen(FlowPickerScreen(), wait_for_dismiss=True)"
      pattern: "FlowPickerScreen.*wait_for_dismiss"
    - from: "src/tui/app.py"
      to: "src/tui/apply.py"
      via: "from tui.apply import extract_code_proposals, write_file_atomic"
      pattern: "write_file_atomic"
    - from: "src/tui/app.py"
      to: "src/tui/widgets/reconciliation_panel.py"
      via: "query_one(ReconciliationPanel).show_reconciliation(...)"
      pattern: "show_reconciliation"
---

<objective>
Wire all Phase 4 flow control and code apply into AgentBureauApp: flow picker gating prompt submission, pick-one vs live-debate routing, debate loop with Esc stop, winner picker, reconciliation agent pass, and apply-confirm gate.

Purpose: This is the integration plan that connects Plans 01-04 into working user flows. All dependencies (messages, modal screens, apply module, widgets) must be complete before this plan executes.
Output: Extended app.py handling all Phase 4 flows; new integration tests for each flow path.
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-flow-control-and-code-apply/04-CONTEXT.md
@.planning/phases/04-flow-control-and-code-apply/04-RESEARCH.md
@src/tui/app.py
@src/tui/session.py
@src/tui/messages.py
@.planning/phases/04-flow-control-and-code-apply/04-01-SUMMARY.md
@.planning/phases/04-flow-control-and-code-apply/04-02-SUMMARY.md
@.planning/phases/04-flow-control-and-code-apply/04-03-SUMMARY.md
@.planning/phases/04-flow-control-and-code-apply/04-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AgentBureauApp with Phase 4 flow control and apply</name>
  <files>src/tui/app.py</files>
  <action>
    Extend src/tui/app.py with the following changes. Read the full existing file first.

    **1. New imports (add to top of file):**
    ```python
    import asyncio  # already present
    from tui.apply import extract_code_proposals, generate_unified_diff, write_file_atomic
    from tui.messages import (  # extend existing import
        AgentFinished, ClassificationDone, TokenReceived,
        RoundBoundary, DebateEnded, ReconciliationReady, ApplyResult,
    )
    from tui.session import SessionState  # already present, SessionState now has Phase 4 states
    from tui.widgets.flow_picker_screen import FlowPickerScreen
    from tui.widgets.winner_picker_screen import WinnerPickerScreen
    from tui.widgets.end_debate_screen import ConfirmEndDebateScreen
    from tui.widgets.apply_confirm_screen import ApplyConfirmScreen
    from tui.widgets.reconciliation_panel import ReconciliationPanel
    ```

    **2. Extend compose() to include ReconciliationPanel:**
    ```python
    def compose(self) -> ComposeResult:
        yield StatusBar(id="status-bar")
        with Horizontal():
            yield AgentPane(agent_name="claude", id="pane-left")
            yield Static("│", id="divider")
            yield AgentPane(agent_name="codex", id="pane-right")
        yield ReconciliationPanel(id="recon-panel")  # hidden by default
        yield PromptBar(id="prompt-bar")
    ```

    **3. Extend on_mount() to initialize Phase 4 state:**
    ```python
    def on_mount(self) -> None:
        self.query_one("#pane-left", AgentPane).focus()
        self._terminal_events: dict[str, BridgeEvent] = {}
        self._agent_line_counts: dict[str, int] = {"claude": 0, "codex": 0}
        self._debate_stop: asyncio.Event = asyncio.Event()
        self._last_texts: dict[str, str] = {}   # {agent_name: full accumulated text} — set after each round/session
        self._agreed_code: str = ""              # agreed code from reconciliation
        self._agreed_language: str = "python"   # language from reconciliation code block
        self._agreed_filename: str | None = None # target filename from reconciliation
    ```

    **4. Extend watch_session_state() to disable input for all non-IDLE states:**
    ```python
    def watch_session_state(self, state: SessionState) -> None:
        try:
            prompt_input = self.query_one("#prompt-input", Input)
            prompt_input.disabled = state != SessionState.IDLE
        except Exception:
            pass
    ```

    **5. Extend _start_session() to reset Phase 4 state:**
    ```python
    def _start_session(self, prompt: str) -> None:
        self._terminal_events = {}
        self._agent_line_counts = {"claude": 0, "codex": 0}
        self._last_texts = {}
        self._agreed_code = ""
        self._agreed_language = "python"
        self._agreed_filename = None
        self._debate_stop.clear()

        # Hide reconciliation panel from previous session
        recon = self.query_one("#recon-panel", ReconciliationPanel)
        recon.hide_panel()

        separator = "\u2500" * 60
        self.query_one("#pane-left", AgentPane).write_token(separator)
        self.query_one("#pane-right", AgentPane).write_token(separator)

        self.session_state = SessionState.FLOW_PICK
        self.run_worker(
            self._run_session(prompt),
            exclusive=True,
            exit_on_error=False,
            name="bridge-session",
        )
    ```

    **6. Replace _run_session() with flow-picker-first version:**
    ```python
    async def _run_session(self, prompt: str) -> None:
        """Worker: show flow picker, then route to pick-one or live-debate."""
        flow: str = await self.push_screen(
            FlowPickerScreen(), wait_for_dismiss=True
        )
        if flow == "live-debate":
            await self._run_live_debate(prompt)
        else:
            await self._run_pick_one(prompt)

    async def _run_pick_one(self, prompt: str) -> None:
        """Worker: fan-out to both agents, collect responses, then go to pick-winner."""
        from tui.bridge import _stream_pty, _stream_pipe, _pty_available, CLAUDE, CODEX
        from tui.event_bus import BridgeEvent

        self.session_state = SessionState.STREAMING
        q: asyncio.Queue[BridgeEvent] = asyncio.Queue()
        stream_fn = _stream_pty if _pty_available() else _stream_pipe

        task_a = asyncio.create_task(stream_fn(CLAUDE, prompt, 60.0, q))
        task_b = asyncio.create_task(stream_fn(CODEX, prompt, 60.0, q))

        collected: dict[str, list[str]] = {"claude": [], "codex": []}
        terminal_count = 0
        while terminal_count < 2:
            event = await q.get()
            if event.type == "token":
                self.post_message(TokenReceived(agent=event.agent, text=event.text))
                collected[event.agent].append(event.text)
            elif event.type in ("done", "error", "timeout"):
                self.post_message(AgentFinished(agent=event.agent, event=event))
                terminal_count += 1

        await asyncio.gather(task_a, task_b)
        self._last_texts = {k: "\n".join(v) for k, v in collected.items()}
        self.post_message(DebateEnded())

    async def _run_live_debate(self, prompt: str) -> None:
        """Worker: run up to MAX_ROUNDS of debate with round-boundary markers."""
        from tui.bridge import _stream_pty, _stream_pipe, _pty_available, CLAUDE, CODEX
        from tui.event_bus import BridgeEvent

        MAX_ROUNDS = 3  # Claude's discretion default; change this constant to adjust
        self._debate_stop.clear()
        self.session_state = SessionState.DEBATING
        stream_fn = _stream_pty if _pty_available() else _stream_pipe

        last_claude = ""
        last_codex = ""

        for round_num in range(1, MAX_ROUNDS + 1):
            if self._debate_stop.is_set():
                break

            self.post_message(RoundBoundary(round_num=round_num))
            self.query_one("#status-bar", StatusBar).show_debating(round_num, MAX_ROUNDS)

            if round_num == 1:
                claude_prompt = prompt
                codex_prompt = prompt
            else:
                claude_prompt = (
                    f"Original task: {prompt}\n\n"
                    f"The other agent proposed:\n{last_codex}\n\n"
                    f"Refine your approach, incorporating the strengths of theirs. Be concise."
                )
                codex_prompt = (
                    f"Original task: {prompt}\n\n"
                    f"The other agent proposed:\n{last_claude}\n\n"
                    f"Refine your approach, incorporating the strengths of theirs. Be concise."
                )

            q: asyncio.Queue[BridgeEvent] = asyncio.Queue()
            task_a = asyncio.create_task(stream_fn(CLAUDE, claude_prompt, 60.0, q))
            task_b = asyncio.create_task(stream_fn(CODEX, codex_prompt, 60.0, q))

            collected: dict[str, list[str]] = {"claude": [], "codex": []}
            terminal_count = 0
            while terminal_count < 2:
                event = await q.get()
                if event.type == "token":
                    self.post_message(TokenReceived(agent=event.agent, text=event.text))
                    collected[event.agent].append(event.text)
                elif event.type in ("done", "error", "timeout"):
                    self.post_message(AgentFinished(agent=event.agent, event=event))
                    terminal_count += 1

            await asyncio.gather(task_a, task_b)
            last_claude = "\n".join(collected["claude"])
            last_codex = "\n".join(collected["codex"])

        self._last_texts = {"claude": last_claude, "codex": last_codex}
        self.post_message(DebateEnded())
    ```

    **7. Add on_round_boundary message handler:**
    ```python
    def on_round_boundary(self, message: RoundBoundary) -> None:
        """Insert a round divider into both agent panes."""
        divider = f"\u2500\u2500 Round {message.round_num} \u2500\u2500"
        self.query_one("#pane-left", AgentPane).write_token(divider)
        self.query_one("#pane-right", AgentPane).write_token(divider)
    ```

    **8. Replace on_agent_finished to update status but NOT trigger classification (classification is now Phase 3 only; Phase 4 defers winner pick to DebateEnded):**

    Keep existing on_agent_finished as-is — it stores terminal events and calls show_done. Remove the classification trigger from it. The classification call moves to on_classification_done (keep that too for Phase 3 path — but in Phase 4 flow the classification step happens inside _run_pick_one after DebateEnded, not in on_agent_finished).

    Actually, to maintain backward compatibility and avoid complexity: keep _run_classification() and on_agent_finished() exactly as they are in Phase 3. The only change is that on_classification_done now checks session state — if state is DONE it proceeds to IDLE (existing behavior); this remains unchanged.

    The DebateEnded message triggers the pick-winner flow independently.

    **9. Add on_debate_ended to push WinnerPickerScreen from a new worker:**
    ```python
    def on_debate_ended(self, message: DebateEnded) -> None:
        """Debate or pick-one streaming complete — push winner picker."""
        self.session_state = SessionState.PICK_WINNER
        self.query_one("#status-bar", StatusBar).show_pick_winner()
        self.run_worker(
            self._pick_winner_flow(),
            exclusive=False,
            exit_on_error=False,
            name="pick-winner",
        )

    async def _pick_winner_flow(self) -> None:
        """Worker: show WinnerPickerScreen, then route to reconciliation or cancel."""
        winner: str = await self.push_screen(
            WinnerPickerScreen(), wait_for_dismiss=True
        )
        if winner == "cancel":
            self.post_message(ApplyResult(confirmed=False, files_written=[]))
            return
        if winner == "keep-discussing":
            # Return to debate — reset for another live-debate round
            # For now: treat as pick-one with current last_texts (debate ended)
            # Re-push the picker to let user reconsider
            winner2: str = await self.push_screen(
                WinnerPickerScreen(), wait_for_dismiss=True
            )
            if winner2 in ("cancel", "keep-discussing"):
                self.post_message(ApplyResult(confirmed=False, files_written=[]))
                return
            winner = winner2

        winning_agent = "claude" if winner == "agent-a" else "codex"
        losing_agent = "codex" if winner == "agent-a" else "claude"
        await self._run_reconciliation(winning_agent, losing_agent)
    ```

    **10. Add _run_reconciliation() for agent convergence pass:**
    ```python
    async def _run_reconciliation(self, winner: str, other: str) -> None:
        """Worker: feed both proposals to winner agent for reconciliation, then show diff."""
        from tui.bridge import _stream_pty, _stream_pipe, _pty_available
        from tui.event_bus import BridgeEvent
        from tui.apply import extract_code_proposals, generate_unified_diff

        self.session_state = SessionState.RECONCILING
        self.query_one("#status-bar", StatusBar).show_reconciling()

        winner_text = self._last_texts.get(winner, "")
        other_text = self._last_texts.get(other, "")

        # Collaborative reconciliation prompt (not adversarial — per CONTEXT.md)
        recon_prompt = (
            f"Here is what Agent A proposed:\n{winner_text}\n\n"
            f"Here is what Agent B proposed:\n{other_text}\n\n"
            f"These are complementary perspectives. Produce the best unified solution "
            f"that incorporates the strengths of both. "
            f"First write a brief plain-language explanation of how you merged the two approaches. "
            f"Then provide the final code in a fenced code block, with the target filename "
            f"as the first line (e.g. # src/module.py)."
        )

        q: asyncio.Queue[BridgeEvent] = asyncio.Queue()
        stream_fn = _stream_pty if _pty_available() else _stream_pipe
        from tui.bridge import CLAUDE
        task = asyncio.create_task(stream_fn(CLAUDE, recon_prompt, 90.0, q))

        recon_tokens: list[str] = []
        while True:
            event = await q.get()
            if event.type == "token":
                recon_tokens.append(event.text)
            elif event.type in ("done", "error", "timeout"):
                break
        await task

        full_recon = "\n".join(recon_tokens)

        # Extract agreed code proposal
        proposals = extract_code_proposals(full_recon)
        if proposals:
            agreed = proposals[-1]  # Use the last code block (final proposal)
            self._agreed_code = agreed.code
            self._agreed_language = agreed.language
            self._agreed_filename = agreed.filename
        else:
            self._agreed_code = ""
            self._agreed_language = "text"
            self._agreed_filename = None

        # Generate diff between winner's original and agreed code
        winner_proposals = extract_code_proposals(winner_text)
        original_code = winner_proposals[-1].code if winner_proposals else ""
        diff_text = generate_unified_diff(
            original_code, self._agreed_code,
            fromfile=winner, tofile="reconciled"
        )

        self.post_message(ReconciliationReady(
            discussion_text=full_recon,
            diff_text=diff_text,
            agreed_code=self._agreed_code,
            language=self._agreed_language,
        ))
    ```

    **11. Add on_reconciliation_ready handler:**
    ```python
    def on_reconciliation_ready(self, message: ReconciliationReady) -> None:
        """Show reconciliation panel, then push apply confirm screen."""
        recon_panel = self.query_one("#recon-panel", ReconciliationPanel)
        recon_panel.show_reconciliation(message.discussion_text, message.diff_text)

        file_count = 1 if self._agreed_filename else 0
        self.session_state = SessionState.CONFIRMING_APPLY
        self.query_one("#status-bar", StatusBar).show_apply_confirm(file_count)

        self.run_worker(
            self._apply_confirm_flow(message),
            exclusive=False,
            exit_on_error=False,
            name="apply-confirm",
        )

    async def _apply_confirm_flow(self, recon: ReconciliationReady) -> None:
        """Worker: push ApplyConfirmScreen, write files only if user confirms."""
        from pathlib import Path
        from tui.apply import write_file_atomic

        confirmed: bool = await self.push_screen(
            ApplyConfirmScreen(), wait_for_dismiss=True
        )

        files_written: list[str] = []
        if confirmed and self._agreed_filename and self._agreed_code:
            target = Path(self._agreed_filename)
            write_file_atomic(target, self._agreed_code)
            files_written.append(str(target))

        self.post_message(ApplyResult(confirmed=confirmed, files_written=files_written))
    ```

    **12. Add on_apply_result handler:**
    ```python
    def on_apply_result(self, message: ApplyResult) -> None:
        """Handle apply result — show outcome and return to IDLE."""
        if message.confirmed and message.files_written:
            status_text = f"Applied — wrote {len(message.files_written)} file(s): {', '.join(message.files_written)}"
        elif message.confirmed:
            status_text = "Applied — no files detected in reconciliation output"
        else:
            status_text = "Cancelled — no files written"

        self.query_one("#status-bar", StatusBar).update(status_text)
        self.session_state = SessionState.IDLE
        self.query_one("#prompt-input", Input).focus()
    ```

    **13. Add action_end_debate for Esc key during debate:**
    Add to BINDINGS: `Binding("escape", "end_debate", "End debate", show=False)`

    ```python
    def action_end_debate(self) -> None:
        """Esc during debate: push confirm screen. Only active in DEBATING state."""
        if self.session_state != SessionState.DEBATING:
            return
        def _on_confirm(confirmed: bool) -> None:
            if confirmed:
                self._debate_stop.set()
        self.push_screen(ConfirmEndDebateScreen(), _on_confirm)
    ```

    CRITICAL ANTI-PATTERNS TO AVOID (from RESEARCH.md):
    - push_screen(wait_for_dismiss=True) MUST only be called from inside a worker coroutine — never from action_* or on_* handlers (use callback form for those)
    - Never write files directly from a worker — post ApplyResult to app, let on_apply_result handle IDLE transition
    - _debate_stop.clear() MUST be called at the start of every _run_live_debate() call (already in step 6 above)
    - Check _debate_stop only between rounds, NOT inside _stream_pty/_stream_pipe (those are reused from Phase 3, do not modify them)
  </action>
  <verify>
    python -c "
    import ast, sys
    with open('/Users/jakeogden/agent-bureau/src/tui/app.py') as f:
        tree = ast.parse(f.read())
    methods = [n.name for n in ast.walk(tree) if isinstance(n, ast.FunctionDef)]
    required = ['_run_session', '_run_pick_one', '_run_live_debate', '_run_reconciliation',
                '_pick_winner_flow', '_apply_confirm_flow',
                'on_round_boundary', 'on_debate_ended', 'on_reconciliation_ready', 'on_apply_result',
                'action_end_debate']
    missing = [m for m in required if m not in methods]
    print('Missing:', missing) if missing else print('All methods present')
    "

    pytest --tb=short
    # All prior tests pass
  </verify>
  <done>
    app.py has all 11 new/extended methods. All Phase 3 tests continue to pass. No import errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for Phase 4 flows</name>
  <files>tests/tui/test_app.py</files>
  <action>
    Append Phase 4 integration tests to the existing tests/tui/test_app.py. Read the full file first to understand existing test patterns (post_message injection pattern, Pilot usage).

    Add these tests using the existing post_message injection pattern (no real subprocesses):

    test_flow_picker_pushed_on_prompt: After input submission in an idle app, session_state == FLOW_PICK (verify state set before flow picker appears)

    test_round_boundary_inserts_divider: Post RoundBoundary(round_num=2) to app, verify both panes contain "── Round 2 ──" text

    test_debate_ended_pushes_pick_winner_state: Post DebateEnded() to app, verify session_state == PICK_WINNER and status bar shows "Pick winner" text

    test_reconciliation_ready_shows_panel: Post ReconciliationReady(discussion_text="discuss", diff_text="", agreed_code="", language="python") to app, verify ReconciliationPanel is visible (display=True)

    test_apply_result_confirmed_returns_to_idle: Post ApplyResult(confirmed=True, files_written=["foo.py"]) to app, verify session_state == IDLE and status bar contains "Applied"

    test_apply_result_rejected_returns_to_idle: Post ApplyResult(confirmed=False, files_written=[]) to app, verify session_state == IDLE and status bar contains "Cancelled"

    NOTE: For tests that check push_screen behavior (like flow picker), use the existing Phase 3 pattern where you directly set session_state and post messages to test the message handlers in isolation. Do NOT try to test the full async _run_session flow in unit tests — that requires real subprocesses.

    Pattern reminder from Phase 3 (test_app.py existing tests):
    ```python
    async def test_something(self) -> None:
        async with self.app.run_test() as pilot:
            self.app.post_message(SomeMessage(...))
            await pilot.pause()
            # assert
    ```
  </action>
  <verify>
    pytest tests/tui/test_app.py -v -k "phase4 or round_boundary or debate_ended or reconciliation or apply_result"
    # All 6 new tests green

    pytest --tb=short
    # Full suite green — all prior tests still passing
  </verify>
  <done>
    6 new integration tests pass in test_app.py. All existing 23 tests continue to pass. Total test count: 29+.
  </done>
</task>

</tasks>

<verification>
python -c "
import ast
with open('/Users/jakeogden/agent-bureau/src/tui/app.py') as f:
    tree = ast.parse(f.read())
methods = [n.name for n in ast.walk(tree) if isinstance(n, ast.FunctionDef)]
required = ['_run_session', '_run_pick_one', '_run_live_debate', '_run_reconciliation',
            'on_round_boundary', 'on_debate_ended', 'on_reconciliation_ready', 'on_apply_result',
            'action_end_debate']
missing = [m for m in required if m not in methods]
print('PASS — all methods present') if not missing else print('MISSING:', missing)
"

pytest --tb=short
# Full suite green
</verification>

<success_criteria>
- app.py has flow picker as first step of _run_session (before any agents run)
- _run_pick_one and _run_live_debate both post DebateEnded() when complete
- _run_live_debate checks _debate_stop.is_set() between rounds; Esc handler sets it via ConfirmEndDebateScreen
- on_debate_ended transitions to PICK_WINNER and launches _pick_winner_flow worker
- _run_reconciliation feeds both proposals to winner agent with collaborative framing
- on_reconciliation_ready shows ReconciliationPanel and launches _apply_confirm_flow worker
- _apply_confirm_flow gates file writes behind ApplyConfirmScreen; uses write_file_atomic for confirmed writes
- on_apply_result returns to IDLE with clear status bar message
- 6 new integration tests pass; all 23+ prior tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-flow-control-and-code-apply/04-05-SUMMARY.md`
</output>
