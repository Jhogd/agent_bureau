---
phase: 04-flow-control-and-code-apply
plan: "03"
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/tui/apply.py
  - tests/tui/test_apply.py
autonomous: true
requirements:
  - APPLY-01
  - APPLY-02
  - APPLY-03

must_haves:
  truths:
    - "extract_code_proposals() parses fenced code blocks from agent output text"
    - "generate_unified_diff() returns a valid unified diff string using difflib"
    - "write_file_atomic() writes content to a file atomically via temp+rename, creating parent dirs"
    - "When no filename comment is found in a code block, CodeProposal.filename is None"
    - "No file is ever written by apply.py without being called explicitly (no side effects)"
  artifacts:
    - path: "src/tui/apply.py"
      provides: "extract_code_proposals(), generate_unified_diff(), write_file_atomic(), CodeProposal dataclass"
      exports:
        - "CodeProposal"
        - "extract_code_proposals"
        - "generate_unified_diff"
        - "write_file_atomic"
    - path: "tests/tui/test_apply.py"
      provides: "TDD tests for all apply functions"
  key_links:
    - from: "src/tui/apply.py"
      to: "src/tui/app.py"
      via: "from tui.apply import extract_code_proposals, generate_unified_diff, write_file_atomic"
      pattern: "extract_code_proposals|write_file_atomic"
---

<objective>
Build src/tui/apply.py — the code extraction, diff generation, and atomic file write module — using strict TDD.

Purpose: This is pure stdlib logic (re, difflib, pathlib, tempfile, os) with clear inputs and outputs, making it the ideal TDD candidate. Having this module proven independently means app wiring can call it without worrying about correctness.
Output: apply.py with CodeProposal dataclass and three functions; test_apply.py proving all behaviors including edge cases.
</objective>

<execution_context>
@/Users/jakeogden/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakeogden/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-flow-control-and-code-apply/04-CONTEXT.md
@.planning/phases/04-flow-control-and-code-apply/04-RESEARCH.md
@src/tui/content.py
</context>

<feature>
  <name>Code proposal extraction, unified diff, and atomic file write</name>
  <files>src/tui/apply.py, tests/tui/test_apply.py</files>
  <behavior>
    CodeProposal dataclass:
      language: str       — programming language (from fence opening, e.g. "python")
      code: str           — extracted code content (without fences, without filename comment line)
      filename: str | None — file path if first code line matches # path/to/file or // path/to/file; else None

    extract_code_proposals(full_text: str) -> list[CodeProposal]:
      - Parses all fenced code blocks delimited by ```language ... ``` (FENCE_OPEN/FENCE_CLOSE patterns from RESEARCH.md)
      - If the first line of a block matches FILE_COMMENT pattern (# filename.ext or // filename.ext), stores it as CodeProposal.filename and excludes it from code content
      - Returns empty list if no fenced blocks found
      - Handles multiple blocks in one text

    generate_unified_diff(a_code: str, b_code: str, fromfile: str = "agent_a", tofile: str = "agent_b") -> str:
      - Uses difflib.unified_diff() with keepends=True on splitlines
      - Returns unified diff string (empty string if inputs are identical)
      - fromfile/tofile appear in diff header lines

    write_file_atomic(target: Path, content: str) -> None:
      - Creates parent dirs with mkdir(parents=True, exist_ok=True)
      - Creates temp file in target.parent (NOT /tmp — same filesystem required)
      - Writes content to temp file, calls os.rename(tmp, target)
      - On any exception during write, unlinks temp file before re-raising
      - After successful write, target file contains exactly content

    Cases:
      extract_code_proposals("```python\nprint('hello')\n```") -> [CodeProposal(language="python", code="print('hello')", filename=None)]
      extract_code_proposals("```python\n# src/foo.py\nprint('hello')\n```") -> [CodeProposal(language="python", code="print('hello')", filename="src/foo.py")]
      extract_code_proposals("no fences here") -> []
      extract_code_proposals("```python\ncode1\n```\n\n```js\ncode2\n```") -> 2 proposals
      generate_unified_diff("a\n", "a\n") -> ""  (identical inputs produce empty diff)
      generate_unified_diff("a\n", "b\n") -> contains "--- agent_a" and "+++ agent_b"
      write_file_atomic(Path(tmp_dir / "sub" / "file.py"), "content") -> file exists with "content", parent created
  </behavior>
  <implementation>
    RED: Write tests/tui/test_apply.py:

      test_extract_single_fenced_block: basic python block, no filename comment
      test_extract_block_with_filename_comment_hash: first line "# src/foo.py" -> filename set, excluded from code
      test_extract_block_with_filename_comment_slash: first line "// src/foo.js" -> filename set
      test_extract_multiple_blocks: two fenced blocks in one text -> 2 proposals
      test_extract_no_blocks: plain text -> empty list
      test_extract_code_without_filename_is_none: code block without comment -> filename is None
      test_generate_diff_identical: same string -> empty diff string
      test_generate_diff_different: different strings -> contains "---" and "+++" and fromfile/tofile names
      test_generate_diff_custom_fromfile: fromfile="agent_claude" appears in diff header
      test_write_file_atomic_creates_file(tmp_path): writes content, file exists
      test_write_file_atomic_creates_parents(tmp_path): target in new subdir, parent created
      test_write_file_atomic_content_correct(tmp_path): file content matches exactly
      test_write_file_atomic_overwrites(tmp_path): writing twice -> second content wins

    Run tests — MUST fail (RED). Commit: test(04-03): add failing tests for apply module

    GREEN: Create src/tui/apply.py:
      Imports: re, os, tempfile, difflib, from pathlib import Path, from dataclasses import dataclass

      FENCE_OPEN = re.compile(r'^```(\w+)$')
      FENCE_CLOSE = re.compile(r'^```$')
      FILE_COMMENT = re.compile(r'^#\s+(\S+\.\w+)$|^//\s+(\S+\.\w+)$')

      @dataclass class CodeProposal with language/code/filename fields.

      extract_code_proposals(): implement loop from RESEARCH.md Pattern 5. Key detail: after detecting FILE_COMMENT on first code line, skip it (i += 1 + continue) so it's not in code_lines.

      generate_unified_diff(): use a_code.splitlines(keepends=True) — NOT splitlines() without keepends (Pitfall 5 from RESEARCH.md). Join diff lines. If result is all whitespace, return "".

      write_file_atomic(): use tempfile.mkstemp(dir=target.parent) — NOT dir="/tmp" (Pitfall 6: cross-filesystem). Use os.fdopen(tmp_fd, 'w') to write, then os.rename(tmp_path, str(target)).

    Run tests — MUST pass (GREEN). Commit: feat(04-03): implement apply module with extract, diff, and atomic write

    REFACTOR: Add module docstring. Ensure all functions have docstrings. No logic changes.
    Commit: refactor(04-03): add module and function docstrings to apply.py
  </implementation>
</feature>

<verification>
pytest tests/tui/test_apply.py -v
# All 13 tests green

pytest --tb=short
# Full suite green (no regressions)

python -c "from tui.apply import extract_code_proposals, generate_unified_diff, write_file_atomic, CodeProposal; print('imports OK')"
</verification>

<success_criteria>
- src/tui/apply.py exists with CodeProposal, extract_code_proposals, generate_unified_diff, write_file_atomic
- tests/tui/test_apply.py has 13 tests, all passing
- Atomic write uses temp file in target.parent (not /tmp)
- Diff uses keepends=True to avoid trailing newline pitfall
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-flow-control-and-code-apply/04-03-SUMMARY.md`
</output>
